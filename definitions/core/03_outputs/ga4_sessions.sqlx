 /*
  This file is part of "GMP Clearview" package.
  Copyright (C)  2025 Infotrust 
  Alina Zilbergerts, Trish Dothkar,
  -- */

config {
  type: "incremental",
  uniqueKey: ['session_id'],
  description: "Intermediate incremental sessions table with modeling helpers implemented. 1 row per unique session_id. Contains only valid sessions.",
  database: dataform.projectConfig.vars.OUTPUT_PROJECT,
  schema: dataform.projectConfig.vars.TRANSFORMATIONS_DATASET,
  name: "ga4_sessions",
  tags:[dataform.projectConfig.vars.GA4_DATASET,"sessions","prod"],
  bigquery: {
    partitionBy: "session_date",
    clusterBy: [ "session_id" ]
    // labels: require("includes/core/helpers.js").helpers.storageLabels()
  }
}

js {
    const { helpers } = require("includes/core/helpers");
    const config = helpers.getConfig();

      var dateFilter = "" ;
    if (dataform.projectConfig.vars.RUN_FOR_DATE != "") {
      dateFilter = ` event_date between date_checkpoint -1 and date_checkpoint `;
    } else { 
      dateFilter = ` event_date >= date_checkpoint -1  `;
    }
}


  -- ==============================
  --            PRE-OPERATIONS
  -- ==============================
  
/* incrementality */
pre_operations {
  declare date_checkpoint DATE;
    ---  // this triple dash means something in dataform?

  -- this is for when we need to refill for certain date
  IF '${dataform.projectConfig.vars.RUN_FOR_DATE}' <> 'undefined' THEN 
    set date_checkpoint = (
      ${when(incremental(), 
          `select date('${dataform.projectConfig.vars.RUN_FOR_DATE}')`, 
          `select date('${config.GA4_START_DATE}')`
           )
      });
      -- delete some older data, since this may be updated later by GA4
      ${
        when(incremental(),
          `delete from ${self()} where session_date = date_checkpoint;`
          )
      }
  ELSE
      set date_checkpoint = (
        ${when(incremental(),
        `select coalesce(max(session_date)+1, date('${config.GA4_START_DATE}'))
            from ${self()} where is_final is True`,
        `select date('${config.GA4_START_DATE}')`)} 
      );
      -- delete some older data, since this may be updated later by GA4
      ${
        when(incremental(),
          `delete from ${self()} where sssion_date >= date_checkpoint;`
          )
      }
    END IF;
}
  -- ==============================
  --        POST-OPERATIONS
  -- ==============================
post_operations {
    ${when(incremental(),
    `EXPORT DATA OPTIONS(
        uri=(CONCAT('gs://${config.GCS_BUCKET}/',  FORMAT_DATE('%Y%m%d' , date_checkpoint), '_gcp_', '${name()}', '_*.parquet')), 
        format='PARQUET',
        overwrite=true
       ) AS

          SELECT DISTINCT * FROM (        -- Overhead SELECT DISTINCT and LIMIT are aded to fix the issue with producting multiple export files insteand of one
          SELECT * FROM ${self()} WHERE session_date = date_checkpoint
          )
          ORDER BY session_id LIMIT 1000000000000000000; `
    )}
}
  -- ==============================
  --            QUERY
  -- ==============================
with events as (
  select
    '${dataform.projectConfig.vars.GA4_DATASET}' as property_id,
    min(event_date) as session_date,
    session_id,
    stream_id,
    user_pseudo_id, 
    max(is_active_user) is_active_user,

    -- last
    ${helpers.generateArrayAggSQL('user_id',false, false)}, -- to account for potentially multiple

    -- min(table_suffix) as table_suffix,

    count(distinct table_suffix) > 1 as is_multiday_session,  -- for later AZ

    -- first
    ${helpers.generateArrayAggSQL('device')},
    ${helpers.generateArrayAggSQL('geo')},
    ${helpers.generateArrayAggSQL('app_info')},
    ${helpers.generateArrayAggSQL('platform')},

    --  traffic info
    -- ${helpers.generateArrayAggSQL('session_traffic_source_last_click', 'session_traffic_source_last_click')} ,
    ${helpers.generateArrayAggSQL('session_traffic_source_last_click.cross_channel_campaign', 'cross_channel_campaign')} ,

    struct(
      ${helpers.generateArrayAggSQL('page.location','landing_page_location')},
      ${helpers.generateArrayAggSQL('page.path','landing_page_path')},
      ${helpers.generateArrayAggSQL('page.hostname','landing_page_hostname')},
      ${helpers.generateArrayAggSQL('page.referrer','landing_page_referrer')},
      ${helpers.generateArrayAggSQL('event_params.content_group','landing_content_group')}
    ) as landing_page,
    -- last
    struct(
      ${helpers.generateArrayAggSQL('page.location','exit_page_location', false)},
      ${helpers.generateArrayAggSQL('page.path','exit_page_path', false)},
      ${helpers.generateArrayAggSQL('page.hostname','exit_page_hostname', false)},
      ${helpers.generateArrayAggSQL('event_params.content_group','exit_content_group', false)}
    ) as exit_page,

    -- these will be packaged to a single struct later
    -- ${helpers.generateTrafficSourceSQL('fixed_traffic_source','first_traffic_source')},
    -- ${helpers.generateTrafficSourceSQL('fixed_traffic_source','last_traffic_source', false)},
    -- ${helpers.generateClickIdTrafficSourceSQL('click_ids',config.CLICK_IDS_ARRAY,'first_click_ids')},
    -- ${helpers.generateClickIdTrafficSourceSQL('click_ids',config.CLICK_IDS_ARRAY,'last_click_ids', false)},

        min(event_params.ga_session_number) as ga_session_number, -- could be NULL when hit comes from MP
        CASE 
          WHEN min(event_params.ga_session_number) = 1 THEN 'new user'
          WHEN min(event_params.ga_session_number) > 1 THEN 'returning user'
          ELSE NULL
        END AS user_type,
        
        logical_or(event_params.session_engaged = 1) as is_engaged_session,
        min(timestamp_micros(event_timestamp)) as session_start_timestamp_utc,
        max(timestamp_micros(event_timestamp)) as session_end_timestamp_utc,
        sum(cast(event_params.engagement_time_msec as int64)) as engagement_time_msec,
        count(event_name) events,
        countif(event_name="page_view") pageviews,
        sum(if(event_name="purchase", ecommerce.purchase_revenue, 0)) purchase_revenue,
        sum(if(event_name="purchase", ecommerce.total_item_quantity,0)) total_item_quantity,
        sum(if(event_name="purchase", ecommerce.unique_items,0)) unique_items, 
        count(distinct if(event_name="purchase", ecommerce.transaction_id, NULL)) transactions,

        -- and key events as metrics
        ${when(
          config.KEY_EVENTS_ARRAY.length > 0,
            `${helpers.getSqlSelectEventsAsMetrics(config.KEY_EVENTS_ARRAY)}  `
          )} ,

       max(is_final) as is_final --return true if session started on an is_final day
    -- struct(
    --   logical_or(event_params.session_engaged = "1") as is_engaged_session,
    --   logical_or(has_source) as is_with_source,
    --   not logical_or(has_source) as is_direct_session
    --   logical_or(url_params.gtm_debug is not null) as is_debug_session,
    --   logical_or(url_params._gl is not null) as is_cross_domain
    -- ) as session_info

  from   ${ref("base_ga4_events")}
  where event_date >= date_checkpoint -1 -- grab 1 extra day, to include sessions starting earlier

  -- only hits with user_pseudo_id and session_id
  and user_pseudo_id is not null
  and session_id is not null
  group by
    property_id,
    session_id,
    stream_id,
    user_pseudo_id
    -- this should not lead to duplicates. If it does, we'll get rid of those in ga4_sessions anyway
),


-- create time struct + session_source struct with first and last traffic_source of the session
add_meta_info as (
  select
    * except (
        -- source,
        -- source_category,
        session_start_timestamp_utc,
        session_end_timestamp_utc,
        engagement_time_msec
        -- first_traffic_source,
        -- last_traffic_source,
        -- first_click_ids,
        -- last_click_ids
        ),
    struct(
      session_start_timestamp_utc,
      session_end_timestamp_utc,
      engagement_time_msec,
      timestamp_diff(session_end_timestamp_utc, session_start_timestamp_utc, second) as session_duration_sec
    ) as time

    -- cross_channel_campaign.*
  from events
),
final as (

select
    current_timestamp() as _run_timestamp, -- indicates when the row was last run
  *  except(is_multiday_session)
from add_meta_info
where (
  session_date >= date_checkpoint -- new sessions
  or is_multiday_session -- or older sessions from yesterday
))
-- could be some incremental duplicates, these will be discarded downstream
-- select session_id,
--  ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY _run_timestamp DESC) as rn
--  from final
select * from final
