 /*
  This file is part of "GMP Clearview" package.
  Copyright (C)  2025 Infotrust 
  Alina Zilbergerts, Trish Dothkar,
  -- */

config {
    type: "incremental",
    tags: [dataform.projectConfig.vars.GA4_DATASET, "pages", "prod"],
    database: dataform.projectConfig.vars.OUTPUT_PROJECT,
    schema: dataform.projectConfig.vars.REPORTING_DATASET,
    name:"ga4_pages",
    description: "Table containing all captured page views",
    bigquery: {
        partitionBy: "event_date", // To improve query performance and control costs. You can only partition based on one dimension.
        clusterBy: ["event_date", "page_id"]
    }
}

js {
    const {
        helpers
    } = require("includes/core/helpers");
    const config = helpers.getConfig();
    /* check if there's invalid columns or dupe columns in the custom column definitions */
    helpers.checkColumnNames(config);

    var dateFilter = "" ;
  if (dataform.projectConfig.vars.RUN_FOR_DATE != "") {
    dateFilter = ` event_date = date_checkpoint `;
  } else { 
    dateFilter = ` event_date >= date_checkpoint `;
  }
}

  -- ==============================
  --            PRE-OPERATIONS 
  -- ==============================
/* incrementality */
pre_operations {
  declare date_checkpoint DATE;
    ---  // this triple dash means something in dataform?

  -- this is for when we need to refill for certain date
  IF '${dataform.projectConfig.vars.RUN_FOR_DATE}' <> 'undefined' THEN 
    set date_checkpoint = (
      ${when(incremental(), 
          `select date('${dataform.projectConfig.vars.RUN_FOR_DATE}')`, 
          `select date('${config.GA4_START_DATE}')`
           )
      });
      -- delete some older data, since this may be updated later by GA4
      ${
        when(incremental(),
          `delete from ${self()} where event_date = date_checkpoint;`
          )
      }
  ELSE
      set date_checkpoint = (
        ${when(incremental(),
        `select coalesce(max(event_date)+1, date('${config.GA4_START_DATE}'))
            from ${self()} where is_final is True`,
        `select date('${config.GA4_START_DATE}')`)} 
      );
      -- delete some older data, since this may be updated later by GA4
      ${
        when(incremental(),
          `delete from ${self()} where event_date >= date_checkpoint;`
          )
      }
    END IF;
}
  -- ==============================
  --        POST-OPERATIONS
  -- ==============================
post_operations {
    ${when(incremental(),
    `EXPORT DATA OPTIONS(
        uri=(CONCAT('gs://${config.GCS_BUCKET}/',  FORMAT_DATE('%Y%m%d' , date_checkpoint), '_gcp_', '${name()}', '_*.parquet')), 
        format='PARQUET',
        overwrite=true
       ) AS

          SELECT DISTINCT * FROM (        -- Overhead SELECT DISTINCT and LIMIT are aded to fix the issue with producting multiple export files insteand of one
          SELECT * FROM ${self()} WHERE event_date = date_checkpoint
          )
          ORDER BY _run_timestamp LIMIT 1000000000000000000; `
    )}
}


  -- ==============================
  --            QUERY
  -- ==============================
with query_source as (
SELECT
  property_id,
  stream_id,
  event_date,
  -- create page ID
  farm_fingerprint(
    event_date ||
    -- coalesce(user_pseudo_id, 'no') ||
    -- coalesce(event_params.ga_session_id, 0) ||
    -- coalesce(batch.batch_page_id, 0) ||
    -- coalesce(batch.batch_ordering_id,0) ||
    -- coalesce(batch.batch_event_index,0) ||
    coalesce(page.location, "")
) as page_id,

      device.category as device_category,
      device.operating_system as operating_system,
      geo.continent as continent, 
      geo.country as country, 
      geo.region as region, 
      geo.city as city,
      app_info.firebase_app_id as firebase_app_id,
      platform,
      cross_channel_campaign.source as session_source,
      cross_channel_campaign.medium as session_medium,
      cross_channel_campaign.default_channel_group as default_channel_group,
      user.user_type as user_type,

  CASE
    WHEN REGEXP_CONTAINS(page.path, r'\/da\/|\/de\/|\/en\/|\/es\/|\/fi\/|\/fr\/|\/it\/|\/nl\/|\/no\/|\/pt\/|\/sv\/') THEN RIGHT(REGEXP_REPLACE(regexp_replace(page.path, r'^https?://[^/]+', ''),r'[\?#].*',''), LENGTH(REGEXP_REPLACE(regexp_replace(page.path, r'^https?://[^/]+', ''),r'[\?#].*',''))-3)
    ELSE REGEXP_REPLACE(regexp_replace(page.path,
      r'^https?://[^/]+',
      ''),r'[\?#].*','')
    END
  AS page_path_cleaned,
    page.location as page_URL,
    page.path as page_path,
    page.title as page_title,
    page.hostname as page_hostname,
    page.referrer as page_referrer,


  -- METRICS

  COUNT(DISTINCT session_id) sessions,
  COUNT(DISTINCT engaged_session_id) engaged_sessions,
  COUNT(*) pageviews,
  SUM(entrances) entrances,
  SUM(exits) exits,
  COUNT(DISTINCT user.user_pseudo_id) users,
  COUNT(DISTINCT IF(user.user_type="new user", user.user_pseudo_id, NULL)) as new_users,
  COUNT(DISTINCT IF(user.user_type="returning user", user.user_pseudo_id, NULL)) as returning_users,
  COUNT(DISTINCT IF(user.is_active_user , user.user_pseudo_id, NULL)) as active_users,
  ROUND(SUM(time_on_page_seconds), 2) AS total_time_on_page_sec,
  ROUND(AVG(time_on_page_seconds), 2) AS avg_time_on_page_sec,
  ROUND(SUM(engagement_time_msec)/1000, 2) AS total_engagement_time_sec,
  ROUND(AVG(engagement_time_msec)/1000, 2) AS avg_engagement_time_sec,

  MIN(is_final) AS is_final,            --return false if even 1 event is not final
FROM
  ${ref("ga4_pageviews")}
WHERE  ${dateFilter}          --event_date >= date_checkpoint 
-- only hits with user_pseudo_id and session_id
  -- and user.user_pseudo_id is not null
  -- and session_id is not null
  group by all
)


select current_timestamp() as _run_timestamp, * 
from query_source


